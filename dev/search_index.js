var documenterSearchIndex = {"docs":
[{"location":"intro/#BOMoD.jl-1","page":"BOMoD.jl","title":"BOMoD.jl","text":"","category":"section"},{"location":"intro/#","page":"BOMoD.jl","title":"BOMoD.jl","text":"A userfriendly package to solve combinatorial modular design optimisation problems within a Bayesian optimisation framework.","category":"page"},{"location":"intro/#Introduction-1","page":"BOMoD.jl","title":"Introduction","text":"","category":"section"},{"location":"intro/#","page":"BOMoD.jl","title":"BOMoD.jl","text":"This section describes the implementation of the package. It can be seen as an extended manual, containing all information needed for further development. In the GitHub repository, a \"quick-start\" can be found in the README file. Figure below shows an overview of the BOMoD pipeline, blue are functions and green are types","category":"page"},{"location":"intro/#","page":"BOMoD.jl","title":"BOMoD.jl","text":"(Image: Manual picture)","category":"page"},{"location":"intro/#","page":"BOMoD.jl","title":"BOMoD.jl","text":"The first section of the manual deals with part A: the construction of the design space. The second section of the manual deals with part B: the new BO pipeline and how the package deals with the modular design input.","category":"page"},{"location":"intro/#","page":"BOMoD.jl","title":"BOMoD.jl","text":"Pages = [\n    \"man/design.md\",\n    \"man/BO_docs.md\"\n]","category":"page"},{"location":"man/BO_docs/#Bayesian-optimisation-1","page":"Bayesian optimisation","title":"Bayesian optimisation","text":"","category":"section"},{"location":"man/BO_docs/#","page":"Bayesian optimisation","title":"Bayesian optimisation","text":"The BO pipeline proposed in the BOMoD package focuses specifically on real-world modular design optimisation problems. There are two significant differences compared to the classical Bayesian optimisation setup:","category":"page"},{"location":"man/BO_docs/#","page":"Bayesian optimisation","title":"Bayesian optimisation","text":"The input is discrete and is represented as a string of characters, containing no numerical information.\nIn wet-lab experiments, it is beneficial to analyse multiple data points simultaneously. This requires the need of a batch sampling algorithm instead of a sequential one.","category":"page"},{"location":"man/BO_docs/#","page":"Bayesian optimisation","title":"Bayesian optimisation","text":"The BOMoD pipeline can be divided into three stages:","category":"page"},{"location":"man/BO_docs/#","page":"Bayesian optimisation","title":"Bayesian optimisation","text":"First sampling step\nSurrogate model\nBatch sampling step","category":"page"},{"location":"man/BO_docs/#","page":"Bayesian optimisation","title":"Bayesian optimisation","text":"Every step will be discussed, and examples will be given. All examples start from a previous constructed design space.","category":"page"},{"location":"man/BO_docs/#","page":"Bayesian optimisation","title":"Bayesian optimisation","text":"julia> using BOMoD\n\njulia> using BOMoD: sample\n\njulia>\nl = 3;\n3\n\njulia> order = true;\ntrue\n\njulia> m = groupmod([\"a\", \"b\", \"c\", \"d\"]);\n{GroupMod}{\"a\", \"b\", \"c\", \"d\"}\n\njulia> design = constructdesign(m,l , order=order);\nUsed modules : {GroupMod}{\"a\", \"b\", \"c\", \"d\"}\nallowed length : 3\nconstraints : BOMoD.NoConstraint{Nothing}(nothing)\n\t \t designspace\n spacetype | BOMoD.FullOrderedSpace{BOMoD.Mod{String}}\n generated constructs | BOMoD.OrderedConstruct{BOMoD.Mod{String}}\n n_consturcts | 64\n\njulia> full_space = getspace(design);\n spacetype | BOMoD.FullOrderedSpace{BOMoD.Mod{String}}\n generated constructs | BOMoD.OrderedConstruct{BOMoD.Mod{String}}\n n_consturcts | 64\n","category":"page"},{"location":"man/BO_docs/#First-sampling-step-1","page":"Bayesian optimisation","title":"First sampling step","text":"","category":"section"},{"location":"man/BO_docs/#","page":"Bayesian optimisation","title":"Bayesian optimisation","text":"The first step of the BOMoD pipeline is sampling the first n data points, which are used to fit the surrogate model of stage two. In the current version of the package, only a  algorithm that samples uniformly at random is available.","category":"page"},{"location":"man/BO_docs/#","page":"Bayesian optimisation","title":"Bayesian optimisation","text":"julia> # sample three random data points\nn = 3\n3\n\njulia> first_sample = sample(full_space,n)\n3-element Array{BOMoD.OrderedConstruct{BOMoD.Mod{String}},1}:\n {OrderedConstruct}[\"a\", \"d\", \"a\"]\n {OrderedConstruct}[\"d\", \"c\", \"a\"]\n {OrderedConstruct}[\"d\", \"d\", \"b\"]\n","category":"page"},{"location":"man/BO_docs/#Surrogate-model-1","page":"Bayesian optimisation","title":"Surrogate model","text":"","category":"section"},{"location":"man/BO_docs/#","page":"Bayesian optimisation","title":"Bayesian optimisation","text":"In the package, GPs are used as surrogate models. Other packages are integrated to handle different steps in the model procedure: The Stheno package was used to fit the GP models efficiently. The package was chosen over other GP packages because custom made kernels can be easily integrated. The StringDistances package is used to calculate string distances between different constructs. The obtained distances are used in the custom kernels, to fit nicely in the Stheno framework . The Optim package is the package used for hyperparameter optimisation of the GP models.","category":"page"},{"location":"man/BO_docs/#","page":"Bayesian optimisation","title":"Bayesian optimisation","text":"The BOMoD package is designed to be simple and straightforward in its use. The well-known fit- and predict workflow was implemented for the GP models. The package provides a way to combine different functionalities of the above-mentioned packages. As a consequence of the easy-to-use philosophy, it is impossible to integrate the full capacity of the given packages. The current version of the BOMoD focuses on the integration of some case-specific functions. This section will first cover how a GP model can be fitted using BOMoD, and afterwards, the prediction for new test data is covered.","category":"page"},{"location":"man/BO_docs/#The-fit_gp-function-1","page":"Bayesian optimisation","title":"The fit_gp function","text":"","category":"section"},{"location":"man/BO_docs/#","page":"Bayesian optimisation","title":"Bayesian optimisation","text":"There is one function fit_gp that fits the entire GP model. The term \"fit\" indicates that the model is conditioned on the given training data and the posterior distribution is obtained. It requires multiple input arguments; some are trivial, others need some additional explanation.","category":"page"},{"location":"man/BO_docs/#","page":"Bayesian optimisation","title":"Bayesian optimisation","text":"arg: x_train, y_train, k::Kernel,mod::GroupMod","category":"page"},{"location":"man/BO_docs/#","page":"Bayesian optimisation","title":"Bayesian optimisation","text":"kwarg: theta =1, sigma^2_n = 10^-6, optimise=false","category":"page"},{"location":"man/BO_docs/#x_train-and-y_train-1","page":"Bayesian optimisation","title":"x_train and y_train`","text":"","category":"section"},{"location":"man/BO_docs/#","page":"Bayesian optimisation","title":"Bayesian optimisation","text":"x_train is a vector containing all constructs that have been evaluated. This means that every construct has a corresponding activity stored in the y_train vector. A construct is represented as a vector of strings, which is obtained from a previous sampling step. No additional transformation of the data is required. The model ensures that for all used functions the proper datatype is given as input. It is advised to store both vectors, x_train and y_train, in a dataframe, using the DataFrames package \\footnote{\\url{https://github.com/JuliaData/DataFrames.jl``. This allows for a well-organised data flow between different iterations of the model. Additionally, a dataframe can be exported to a CSV file for long-term storage.","category":"page"},{"location":"man/BO_docs/#","page":"Bayesian optimisation","title":"Bayesian optimisation","text":"julia> using DataFrames\n\njulia> # sample some random x_train samples\nx_train = sample(full_space,3);\n3-element Array{BOMoD.OrderedConstruct{BOMoD.Mod{String}},1}:\n {OrderedConstruct}[\"b\", \"d\", \"d\"]\n {OrderedConstruct}[\"c\", \"a\", \"c\"]\n {OrderedConstruct}[\"a\", \"a\", \"b\"]\n\njulia> # sample some random activity values\ny_train = randn(length(x_train));\n3-element Array{Float64,1}:\n 0.355016080112298\n 0.17486131913864977\n 0.4317700578229935\n\njulia> # Store the both in a dataframe\ndf = DataFrame(x_train=x_train ,y_train=y_train);\n3×2 DataFrames.DataFrame\n│ Row │ x_train                           │ y_train  │\n│     │ BOMoD.OrderedConstruct…           │ Float64  │\n├─────┼───────────────────────────────────┼──────────┤\n│ 1   │ {OrderedConstruct}[\"b\", \"d\", \"d\"] │ 0.355016 │\n│ 2   │ {OrderedConstruct}[\"c\", \"a\", \"c\"] │ 0.174861 │\n│ 3   │ {OrderedConstruct}[\"a\", \"a\", \"b\"] │ 0.43177  │\n","category":"page"},{"location":"man/BO_docs/#k::Kernel-1","page":"Bayesian optimisation","title":"k::Kernel","text":"","category":"section"},{"location":"man/BO_docs/#","page":"Bayesian optimisation","title":"Bayesian optimisation","text":"The kernel that is used has a substantial effect on the prediction capacity of the model. It tries to find structure among the different training data points. Depending on the problem, different kernels are preferred. Various kernels are implemented in the package. All of them were developed to deal with the specific modular design input, a vector containing a vector of strings. The general idea of the BOMoD package is to keep everything as simple as possible. Every kernel has received its custom type. The Kernel abstract type of Stheno was reexported, and all custom kernels were brought under this abstract type, which is mandatory to fit a GP in the Stheno ecosystem. Different kernel options are implemented and discussed below:","category":"page"},{"location":"man/BO_docs/#","page":"Bayesian optimisation","title":"Bayesian optimisation","text":"a) Transformation to a vector embedding.","category":"page"},{"location":"man/BO_docs/#","page":"Bayesian optimisation","title":"Bayesian optimisation","text":"The first kernel type transforms the string vector in a numbered vector using a bag-of-words algorithm. These vectors can be used in the standard kernels implemented in Stheno. The package has been tested using the linear kernel of the Stheno package. However, this approach should make all Stheno base-kernels available. The linear kernel can be used with given structure:","category":"page"},{"location":"man/BO_docs/#","page":"Bayesian optimisation","title":"Bayesian optimisation","text":"julia> k = Linear();\nStheno.Linear()\n","category":"page"},{"location":"man/BO_docs/#","page":"Bayesian optimisation","title":"Bayesian optimisation","text":"b) Edit distances kernel","category":"page"},{"location":"man/BO_docs/#","page":"Bayesian optimisation","title":"Bayesian optimisation","text":"The EditDistancesKernel is a custom kernel type for kernels based on the edit distance between all input vectors. The StringDistances package is used to calculate the edit distance. In the current version of the package, only the Levenshtein distance has been tested. The calculated Levenshtein distance between mathbfx_i and mathbfx_j is transformed in a kernel using:","category":"page"},{"location":"man/BO_docs/#","page":"Bayesian optimisation","title":"Bayesian optimisation","text":"K(mathbfx_imathbfx_j) = e^textlev mathbfx_imathbfx_j","category":"page"},{"location":"man/BO_docs/#","page":"Bayesian optimisation","title":"Bayesian optimisation","text":"The kernel is designed to work with all other edit distances available in the StringDistances package. This is still in an experimental phase and errors could occur. In the general case, EditDistancesKernel takes one argument: the chosen edit distance.","category":"page"},{"location":"man/BO_docs/#","page":"Bayesian optimisation","title":"Bayesian optimisation","text":"julia> using StringDistances\n\njulia> k = EditDistancesKernel(Levenshtein());\nBOMoD.EditDistancesKernel{StringDistances.Levenshtein}(StringDistances.Levenshtein())\n","category":"page"},{"location":"man/BO_docs/#","page":"Bayesian optimisation","title":"Bayesian optimisation","text":"It should be noted that the edit distance takes the relative position of different combinations into account as illustrated in the given example:","category":"page"},{"location":"man/BO_docs/#","page":"Bayesian optimisation","title":"Bayesian optimisation","text":"julia> using StringDistances\n\njulia> example1 = [:a, :b, :c];\n3-element Array{Symbol,1}:\n :a\n :b\n :c\n\njulia> example2 = [:a, :c, :b];\n3-element Array{Symbol,1}:\n :a\n :c\n :b\n\njulia> example3 = [:a, :c, :d];\n3-element Array{Symbol,1}:\n :a\n :c\n :d\n\njulia>\n# The Levenshteinkernel of two identical constructs is 1)\nidentical = -evaluate(Levenshtein(),example1,example1) |> exp\n1.0\n\njulia>\n#The Levenshtein of two constructs with only a position shift is exp(2)\nshift = -evaluate(Levenshtein(),example1,example2) |> exp\n0.1353352832366127\n\njulia>\n#The Levenshtein of two constructs with shift and change is again exp(2)\nchange = -evaluate(Levenshtein(),example1,example3) |> exp\n0.1353352832366127\n","category":"page"},{"location":"man/BO_docs/#","page":"Bayesian optimisation","title":"Bayesian optimisation","text":"As a consequence, this kernel is suited to deal with OrderedConstruct combinations.","category":"page"},{"location":"man/BO_docs/#","page":"Bayesian optimisation","title":"Bayesian optimisation","text":"c) q-gram kernel","category":"page"},{"location":"man/BO_docs/#","page":"Bayesian optimisation","title":"Bayesian optimisation","text":"The QGramKernel uses q-gram similarities between constructs to obtain a useful kernel. q-gram similarities between two constructs are calculated based on the presence of mutual sub-strings, independent of their specific position. The \"q\" value refers to the length of the sub-string that is evaluated. In the given setup of the package, only the cosine similarity with q = 1 is used.","category":"page"},{"location":"man/BO_docs/#","page":"Bayesian optimisation","title":"Bayesian optimisation","text":"To calculate the cosine similarities, the StringDistances package is used. This function internally handles the bag-of-words transformation and the constructs can be used as input. The obtained distances are transformed into the corresponding kernel by:","category":"page"},{"location":"man/BO_docs/#","page":"Bayesian optimisation","title":"Bayesian optimisation","text":"k(mathbfx_imathbfx_j)= 1 - textcosinemathbfx_imathbfx_j","category":"page"},{"location":"man/BO_docs/#","page":"Bayesian optimisation","title":"Bayesian optimisation","text":"where mathbfx_i, mathbfx_j are two constructs. The StringDistances package provides a range of q-gram distances, all can be transformed into a similarity value. The cosine distance with q = 1 is the only q-gram distance that was tested. Again the other q-gram distances available in the StringDistances package can be used, but this is still in an experimental phase, and errors could occur.","category":"page"},{"location":"man/BO_docs/#","page":"Bayesian optimisation","title":"Bayesian optimisation","text":"julia> k = QGramKernel(StringDistances.Cosine(1))\nBOMoD.QGramKernel{StringDistances.Cosine}(StringDistances.Cosine(1))\n","category":"page"},{"location":"man/BO_docs/#","page":"Bayesian optimisation","title":"Bayesian optimisation","text":"The cosine similarity counts the occurrence of every module, as a result all position information is lost. This is a large difference compared to the Levenshtein distance. This is illustrated with the same example as used in the case of the Levenshtein distance.","category":"page"},{"location":"man/BO_docs/#","page":"Bayesian optimisation","title":"Bayesian optimisation","text":"julia> using StringDistances\n\njulia> example1 = [:a, :b, :c];\n3-element Array{Symbol,1}:\n :a\n :b\n :c\n\njulia> example2 = [:a, :c, :b];\n3-element Array{Symbol,1}:\n :a\n :c\n :b\n\njulia> example3 = [:a, :c, :d];\n3-element Array{Symbol,1}:\n :a\n :c\n :d\n\njulia>\n# \"The Cosine similarity of two identical constructs is 1\nidentical = 1 - evaluate(StringDistances.Cosine(1),example1,example1) |> x ->  round(x,digits = 3)\n1.0\n\njulia>\n# \"The Cosine similarity constructs with only a position shift is 1\ntwisted  = 1 - evaluate(StringDistances.Cosine(1),example1,example2) |>  x ->  round(x,digits = 3)\n1.0\n\njulia>\n#\"The Cosine similarity constructs with only a position shift and change is again 0.667\nchange = 1 - evaluate(StringDistances.Cosine(1),example1,example3) |>  x -> round(x,digits = 3)\n0.667\n","category":"page"},{"location":"man/BO_docs/#","page":"Bayesian optimisation","title":"Bayesian optimisation","text":"As a consequence, this kernel is suited to deal with UnorderedConstruct types and can be used for OrderedConstruct types depending on the given problem.","category":"page"},{"location":"man/BO_docs/#","page":"Bayesian optimisation","title":"Bayesian optimisation","text":"d) Composed Kernels","category":"page"},{"location":"man/BO_docs/#","page":"Bayesian optimisation","title":"Bayesian optimisation","text":"Multiplication or concatenation of different kernels result in newly composed kernels. In BOMoD, the main focus is on combining the QGramKernel and EditDistancesKernel. As seen in the examples above, both discover different patterns in the same constructs. If they are used together, the strengths of both kernels are combined.","category":"page"},{"location":"man/BO_docs/#","page":"Bayesian optimisation","title":"Bayesian optimisation","text":"An example of a composed kernel is:","category":"page"},{"location":"man/BO_docs/#","page":"Bayesian optimisation","title":"Bayesian optimisation","text":"julia> k = EditDistancesKernel(Levenshtein()) + QGramKernel(StringDistances.Cosine(1));\nStheno.Sum{BOMoD.EditDistancesKernel{StringDistances.Levenshtein},BOMoD.QGramKernel{StringDistances.Cosine}}(BOMoD.EditDistancesKernel{StringDistances.Levenshtein}(StringDistances.Levenshtein()), BOMoD.QGramKernel{StringDistances.Cosine}(StringDistances.Cosine(1)))\n","category":"page"},{"location":"man/BO_docs/#","page":"Bayesian optimisation","title":"Bayesian optimisation","text":"Unfortunately, the current implementation of the linear kernel in Stheno requires a unique input structure. This makes it not possible to combine it with the other given string kernels.","category":"page"},{"location":"man/BO_docs/#mod::GroupMod-1","page":"Bayesian optimisation","title":"mod::GroupMod","text":"","category":"section"},{"location":"man/BO_docs/#","page":"Bayesian optimisation","title":"Bayesian optimisation","text":"The mod argument contains the input modules, and they are used to transform the data into a vector embedding, if needed.","category":"page"},{"location":"man/BO_docs/#","page":"Bayesian optimisation","title":"Bayesian optimisation","text":"julia> m = groupmod([\"a\", \"b\", \"c\", \"d\"]);\n{GroupMod}{\"a\", \"b\", \"c\", \"d\"}\n","category":"page"},{"location":"man/BO_docs/#","page":"Bayesian optimisation","title":"Bayesian optimisation","text":"Above, the four mandatory arguments to fit a GP model were discussed. The other arguments are optional keyword arguments with a given default value. Still, these parameters can have a significant effect on the performance of the model.","category":"page"},{"location":"man/BO_docs/#θ-(default-[1])-1","page":"Bayesian optimisation","title":"θ (default = [1])","text":"","category":"section"},{"location":"man/BO_docs/#","page":"Bayesian optimisation","title":"Bayesian optimisation","text":"The theta vector contains the hyperparameter of the GP model. Only one hyperparameter is used for all different kernels to reduce the complexity of the models. In all cases, this is the scaling parameter alpha of the GP model.","category":"page"},{"location":"man/BO_docs/#","page":"Bayesian optimisation","title":"Bayesian optimisation","text":"y = alpha * GP","category":"page"},{"location":"man/BO_docs/#","page":"Bayesian optimisation","title":"Bayesian optimisation","text":"Still, it is important that the parameter is given as a vector. The \\theta $ vector is ignored if optimise=true","category":"page"},{"location":"man/BO_docs/#\\sigma2_n-(default-[10{-6}])-1","page":"Bayesian optimisation","title":"sigma^2_n (default = [10^-6])","text":"","category":"section"},{"location":"man/BO_docs/#","page":"Bayesian optimisation","title":"Bayesian optimisation","text":"sigma^2_n is the noise parameter of the GP model. The Stheno model requires a low noise factor for numerical stability. The noise factor can have two different inputs:","category":"page"},{"location":"man/BO_docs/#","page":"Bayesian optimisation","title":"Bayesian optimisation","text":"One single noise factor for all training data\nA vector containing a value for every training data point separately. The length of the vector equals the length of x_train.","category":"page"},{"location":"man/BO_docs/#optimise-(default-[false])-1","page":"Bayesian optimisation","title":"optimise (default = [false])","text":"","category":"section"},{"location":"man/BO_docs/#","page":"Bayesian optimisation","title":"Bayesian optimisation","text":"The optimise argument takes a boolean input, true or false. If the argument is set to true the fit_gp function will optimise the hyperparameter of the GP model. The optimal hyperparameter is obtained after maximisation of the log marginal likelihood implemented in Stheno. The optimisation uses the Golden section algorithm  from the Optim package. Golden section is used because it avoids the calculation of gradients and is sufficient because only a single hyperparameter needs to be optimised. The initial upper and lower boundary of the algorithm is texte^-5texte^10. This ensures numerical stability of the model that is calculated during the optimisation procedure.","category":"page"},{"location":"man/BO_docs/#","page":"Bayesian optimisation","title":"Bayesian optimisation","text":"Bringing all the above mentioned arguments together in the fit_gp function gives:","category":"page"},{"location":"man/BO_docs/#","page":"Bayesian optimisation","title":"Bayesian optimisation","text":"julia> a_gp_model = fit_gp(x_train,y_train,EditDistancesKernel(Levenshtein()),m);","category":"page"},{"location":"man/BO_docs/#","page":"Bayesian optimisation","title":"Bayesian optimisation","text":"The output is a GPModel structure containing  three arguments:","category":"page"},{"location":"man/BO_docs/#","page":"Bayesian optimisation","title":"Bayesian optimisation","text":"hatf: The Stheno object of the fitted GP model.\nK: A kernel object of the used kernel in the GP model.\ntheta: A dictionary containing the used hyperparameter and the noise parameter with their corresponding values.","category":"page"},{"location":"man/BO_docs/#experimental-function:-fit_gp_graph-1","page":"Bayesian optimisation","title":"experimental function: fit_gp_graph`","text":"","category":"section"},{"location":"man/BO_docs/#","page":"Bayesian optimisation","title":"Bayesian optimisation","text":"A fit_gp_graph function is available in the package.  The kernels used in this function are based on an underlying graph structure. Of course, this requires first the construction of a graph containing all different combinations.  These combinations are positioned in a weighted graph where the weights of the edges are calculated based on the string distance between the two constructs they connect.  Because a graph containing all constructs is constructed first, the inputs of the fit_gp_graph function deviate slightly from the classical fit_gp function.","category":"page"},{"location":"man/BO_docs/#","page":"Bayesian optimisation","title":"Bayesian optimisation","text":"arg: S, x_train, y_train, k::KernelGraph,  edgerule::EdgeRule","category":"page"},{"location":"man/BO_docs/#","page":"Bayesian optimisation","title":"Bayesian optimisation","text":"kwarg: theta= 1, sigma^2_n = 10^-6, optimise = false","category":"page"},{"location":"man/BO_docs/#S-:-The-Design-space-1","page":"Bayesian optimisation","title":"S : The Design space","text":"","category":"section"},{"location":"man/BO_docs/#","page":"Bayesian optimisation","title":"Bayesian optimisation","text":"S is the entire design space of the modular design problem and is needed to construct the underlying graph, which is used to compute the kernel.","category":"page"},{"location":"man/BO_docs/#x*train-and-y*train-1","page":"Bayesian optimisation","title":"xtrain and ytrain","text":"","category":"section"},{"location":"man/BO_docs/#","page":"Bayesian optimisation","title":"Bayesian optimisation","text":"The kernel value between the two constructs is no longer independent of all other possible combinations. The entire graph network is used to calculate the kernel value between two constructs, which has as consequence that the entire graph and the corresponding kernel have to be precomputed to fit the GP model correctly. All kernel values between all combinations of the design space S  are stored in a large matrix and afterwards transformed in a Precomputed structure to fit the GP model. An important side effect of using precomputed kernels is that the indices of the x_train values are required and not the constructs themselves. An error will occur when the wrong input is used.","category":"page"},{"location":"man/BO_docs/#","page":"Bayesian optimisation","title":"Bayesian optimisation","text":"For EffSpace the indices can be obtained setting the with_index argument to true. The returned tuple contains the constructs and the corresponding indices.","category":"page"},{"location":"man/BO_docs/#","page":"Bayesian optimisation","title":"Bayesian optimisation","text":"julia> first_sample,indexes = sample(full_space,n,with_index = true);\n(BOMoD.OrderedConstruct{BOMoD.Mod{String}}[{OrderedConstruct}[\"a\", \"b\", \"a\"], {OrderedConstruct}[\"a\", \"a\", \"b\"], {OrderedConstruct}[\"a\", \"b\", \"c\"]], [5, 2, 7])\n","category":"page"},{"location":"man/BO_docs/#","page":"Bayesian optimisation","title":"Bayesian optimisation","text":"For all other space types, the indices are returned by default as the second argument.","category":"page"},{"location":"man/BO_docs/#","page":"Bayesian optimisation","title":"Bayesian optimisation","text":"If the design space is stored in an array, it is advised to sample from all possible indices and not from the design space directly. The corresponding construct can then be obtained using the given indices.","category":"page"},{"location":"man/BO_docs/#","page":"Bayesian optimisation","title":"Bayesian optimisation","text":"julia> explicit_space = collect(full_space);\n64-element Array{BOMoD.OrderedConstruct{BOMoD.Mod{String}},1}:\n {OrderedConstruct}[\"a\", \"a\", \"a\"]\n {OrderedConstruct}[\"a\", \"a\", \"b\"]\n {OrderedConstruct}[\"a\", \"a\", \"c\"]\n {OrderedConstruct}[\"a\", \"a\", \"d\"]\n {OrderedConstruct}[\"a\", \"b\", \"a\"]\n {OrderedConstruct}[\"a\", \"b\", \"b\"]\n {OrderedConstruct}[\"a\", \"b\", \"c\"]\n {OrderedConstruct}[\"a\", \"b\", \"d\"]\n {OrderedConstruct}[\"a\", \"c\", \"a\"]\n {OrderedConstruct}[\"a\", \"c\", \"b\"]\n ⋮\n {OrderedConstruct}[\"d\", \"b\", \"d\"]\n {OrderedConstruct}[\"d\", \"c\", \"a\"]\n {OrderedConstruct}[\"d\", \"c\", \"b\"]\n {OrderedConstruct}[\"d\", \"c\", \"c\"]\n {OrderedConstruct}[\"d\", \"c\", \"d\"]\n {OrderedConstruct}[\"d\", \"d\", \"a\"]\n {OrderedConstruct}[\"d\", \"d\", \"b\"]\n {OrderedConstruct}[\"d\", \"d\", \"c\"]\n {OrderedConstruct}[\"d\", \"d\", \"d\"]\n\njulia> indexes = sample(1:length(explicit_space),n);;\n3-element Array{Int64,1}:\n 15\n  2\n 38\n\njulia> contructs = explicit_space[indexes]\n3-element Array{BOMoD.OrderedConstruct{BOMoD.Mod{String}},1}:\n {OrderedConstruct}[\"a\", \"d\", \"c\"]\n {OrderedConstruct}[\"a\", \"a\", \"b\"]\n {OrderedConstruct}[\"c\", \"b\", \"b\"]\n","category":"page"},{"location":"man/BO_docs/#","page":"Bayesian optimisation","title":"Bayesian optimisation","text":"The vector y_train still contains the activity value of the given x_train inputs.","category":"page"},{"location":"man/BO_docs/#EdgeRule-1","page":"Bayesian optimisation","title":"EdgeRule","text":"","category":"section"},{"location":"man/BO_docs/#","page":"Bayesian optimisation","title":"Bayesian optimisation","text":"A new type, EdgeRule, is introduced, to set the desired weight on the edges of the graph. As for the different kernels, the string distances from the StringDistances package were transformed into similarities and then used as weights on edges of the graph. Currently, the Levenshtein distance and the cosine distance are implemented, which are used with the following structures.","category":"page"},{"location":"man/BO_docs/#","page":"Bayesian optimisation","title":"Bayesian optimisation","text":"julia> levenstein_edgerule = LevRule();\nBOMoD.LevRule()\n\njulia> cosine_edgerule = CosRule();\nBOMoD.CosRule()\n","category":"page"},{"location":"man/BO_docs/#","page":"Bayesian optimisation","title":"Bayesian optimisation","text":"The edge rules are used to construct the adjacency matrix, which allows for the calculation of the normalised Laplacian tildemathcalL. These steps are all done automatically in the package with an internal function: setupgraph. The normalised Laplacian is then used to obtain the kernel.","category":"page"},{"location":"man/BO_docs/#k::KernelGraph-1","page":"Bayesian optimisation","title":"k::KernelGraph","text":"","category":"section"},{"location":"man/BO_docs/#","page":"Bayesian optimisation","title":"Bayesian optimisation","text":"The kernels used on a graph received a specific abstract type KernelGraph. BOMoD provides two kernels which use a graph structure, both are in an experimental phase.","category":"page"},{"location":"man/BO_docs/#","page":"Bayesian optimisation","title":"Bayesian optimisation","text":"The first kernel is the diffusion kernel:","category":"page"},{"location":"man/BO_docs/#","page":"Bayesian optimisation","title":"Bayesian optimisation","text":"K = e^beta tildemathcalL","category":"page"},{"location":"man/BO_docs/#","page":"Bayesian optimisation","title":"Bayesian optimisation","text":"where beta is the hyperparameter of the kernel. The diffusion kernel can be used with the DiffusionKernel() structure.","category":"page"},{"location":"man/BO_docs/#","page":"Bayesian optimisation","title":"Bayesian optimisation","text":"julia> k = DiffusionKernel();\nBOMoD.DiffusionKernel()\n","category":"page"},{"location":"man/BO_docs/#","page":"Bayesian optimisation","title":"Bayesian optimisation","text":"The second kernel is the p-random walk kernel:","category":"page"},{"location":"man/BO_docs/#","page":"Bayesian optimisation","title":"Bayesian optimisation","text":"K = (aI - tildemathcalL)^p","category":"page"},{"location":"man/BO_docs/#","page":"Bayesian optimisation","title":"Bayesian optimisation","text":"where I is the identity matrix, $ a \\le 2$ and $ p > 1$.","category":"page"},{"location":"man/BO_docs/#","page":"Bayesian optimisation","title":"Bayesian optimisation","text":"The p-random walk kernel can be used with the PRandomKernel(p) setting.","category":"page"},{"location":"man/BO_docs/#","page":"Bayesian optimisation","title":"Bayesian optimisation","text":"julia> using BOMoD: PRandomKernel\n\njulia>\n k = PRandomKernel(2);\nBOMoD.PRandomKernel(2)\n","category":"page"},{"location":"man/BO_docs/#","page":"Bayesian optimisation","title":"Bayesian optimisation","text":"More information regarding the kernels is given in:","category":"page"},{"location":"man/BO_docs/#","page":"Bayesian optimisation","title":"Bayesian optimisation","text":"Risi Imre Kondor and John D. Lafferty. 2002. Diffusion Kernels on Graphs and Other Discrete Input Spaces. In Proceedings of the Nineteenth International Conference on Machine Learning (ICML ’02). Morgan Kaufmann Publishers Inc., San Francisco, CA, USA, 315–322.","category":"page"},{"location":"man/BO_docs/#","page":"Bayesian optimisation","title":"Bayesian optimisation","text":"Smola A.J., Kondor R. (2003) Kernels and Regularisation on Graphs. In: Schölkopf B., Warmuth M.K. (eds) Learning Theory and Kernel Machines. Lecture Notes in Computer Science, vol 2777. Springer, Berlin, Heidelberg","category":"page"},{"location":"man/BO_docs/#","page":"Bayesian optimisation","title":"Bayesian optimisation","text":"The given key word arguments have the same explanation as for the standard fit_gp function and are not repeated.","category":"page"},{"location":"man/BO_docs/#","page":"Bayesian optimisation","title":"Bayesian optimisation","text":"An example is given to fit a GP model using a kernel on a graph. The Levenshtein distance, LevRule(), is used to obtain the weight of the edges and the diffusion kernel, DiffusionKernel(), is used.","category":"page"},{"location":"man/BO_docs/#","page":"Bayesian optimisation","title":"Bayesian optimisation","text":"julia> using BOMoD: fit_gp_graph\n\njulia> first_sample,indexes = sample(full_space,3,with_index = true);\n(BOMoD.OrderedConstruct{BOMoD.Mod{String}}[{OrderedConstruct}[\"d\", \"b\", \"d\"], {OrderedConstruct}[\"a\", \"c\", \"d\"], {OrderedConstruct}[\"c\", \"c\", \"a\"]], [56, 12, 41])\n\njulia> x_train_graph = indexes;\n3-element Array{Int64,1}:\n 56\n 12\n 41\n\njulia> eltype(indexes);\nInt64\n\njulia> y_train = randn(3);\n3-element Array{Float64,1}:\n -0.20641673601235763\n  0.46901778102928354\n  1.7723410453635258\n\njulia> S = collect(full_space);\n64-element Array{BOMoD.OrderedConstruct{BOMoD.Mod{String}},1}:\n {OrderedConstruct}[\"a\", \"a\", \"a\"]\n {OrderedConstruct}[\"a\", \"a\", \"b\"]\n {OrderedConstruct}[\"a\", \"a\", \"c\"]\n {OrderedConstruct}[\"a\", \"a\", \"d\"]\n {OrderedConstruct}[\"a\", \"b\", \"a\"]\n {OrderedConstruct}[\"a\", \"b\", \"b\"]\n {OrderedConstruct}[\"a\", \"b\", \"c\"]\n {OrderedConstruct}[\"a\", \"b\", \"d\"]\n {OrderedConstruct}[\"a\", \"c\", \"a\"]\n {OrderedConstruct}[\"a\", \"c\", \"b\"]\n ⋮\n {OrderedConstruct}[\"d\", \"b\", \"d\"]\n {OrderedConstruct}[\"d\", \"c\", \"a\"]\n {OrderedConstruct}[\"d\", \"c\", \"b\"]\n {OrderedConstruct}[\"d\", \"c\", \"c\"]\n {OrderedConstruct}[\"d\", \"c\", \"d\"]\n {OrderedConstruct}[\"d\", \"d\", \"a\"]\n {OrderedConstruct}[\"d\", \"d\", \"b\"]\n {OrderedConstruct}[\"d\", \"d\", \"c\"]\n {OrderedConstruct}[\"d\", \"d\", \"d\"]\n\njulia> fit_gp_graph(S,x_train_graph,y_train,DiffusionKernel(),LevRule());","category":"page"},{"location":"man/BO_docs/#The-predict_gp-function-1","page":"Bayesian optimisation","title":"The predict_gp function","text":"","category":"section"},{"location":"man/BO_docs/#","page":"Bayesian optimisation","title":"Bayesian optimisation","text":"The predict_gp function is a straightforward wrapper to fit the desired x_test values in the Stheno framework. There are two different options to use the function.","category":"page"},{"location":"man/BO_docs/#Prediction-for-all-unseen-data-1","page":"Bayesian optimisation","title":"Prediction for all unseen data","text":"","category":"section"},{"location":"man/BO_docs/#","page":"Bayesian optimisation","title":"Bayesian optimisation","text":"The first option provides a tool to predict the activity values for all unseen constructs. The filter step filters the training data from the design space which is done within the function. The function takes four arguments, which were all obtained in the previous stages of the BOMoD process.","category":"page"},{"location":"man/BO_docs/#","page":"Bayesian optimisation","title":"Bayesian optimisation","text":"S: the whole search space S xtrain: a data set of all previously evaluated data points model: GPmodel object obtained from `gpfitfunction m:GroupMod` object containing all modules, used to transform the data.","category":"page"},{"location":"man/BO_docs/#","page":"Bayesian optimisation","title":"Bayesian optimisation","text":"julia> S = collect(full_space);\n64-element Array{BOMoD.OrderedConstruct{BOMoD.Mod{String}},1}:\n {OrderedConstruct}[\"a\", \"a\", \"a\"]\n {OrderedConstruct}[\"a\", \"a\", \"b\"]\n {OrderedConstruct}[\"a\", \"a\", \"c\"]\n {OrderedConstruct}[\"a\", \"a\", \"d\"]\n {OrderedConstruct}[\"a\", \"b\", \"a\"]\n {OrderedConstruct}[\"a\", \"b\", \"b\"]\n {OrderedConstruct}[\"a\", \"b\", \"c\"]\n {OrderedConstruct}[\"a\", \"b\", \"d\"]\n {OrderedConstruct}[\"a\", \"c\", \"a\"]\n {OrderedConstruct}[\"a\", \"c\", \"b\"]\n ⋮\n {OrderedConstruct}[\"d\", \"b\", \"d\"]\n {OrderedConstruct}[\"d\", \"c\", \"a\"]\n {OrderedConstruct}[\"d\", \"c\", \"b\"]\n {OrderedConstruct}[\"d\", \"c\", \"c\"]\n {OrderedConstruct}[\"d\", \"c\", \"d\"]\n {OrderedConstruct}[\"d\", \"d\", \"a\"]\n {OrderedConstruct}[\"d\", \"d\", \"b\"]\n {OrderedConstruct}[\"d\", \"d\", \"c\"]\n {OrderedConstruct}[\"d\", \"d\", \"d\"]\n\njulia> prediction = predict_gp(S,x_train,a_gp_model,m);","category":"page"},{"location":"man/BO_docs/#","page":"Bayesian optimisation","title":"Bayesian optimisation","text":"For the prediction of models using kernels on a graph, the provided design space S should contain all indices and not the constructs themselves, because x_train contains all indices of the given data points. See fit_gp_graph for more information.","category":"page"},{"location":"man/BO_docs/#Prediction-user-defined-test-set-1","page":"Bayesian optimisation","title":"Prediction user-defined test set","text":"","category":"section"},{"location":"man/BO_docs/#","page":"Bayesian optimisation","title":"Bayesian optimisation","text":"A second option is to make predictions for a user-defined test set of constructs. First, these selected constructs are transformed to fit smoothly in the BOMoD ecosystem.","category":"page"},{"location":"man/BO_docs/#","page":"Bayesian optimisation","title":"Bayesian optimisation","text":"julia> # our two construct  user-defined-test-constructs.\nc₁= [\"b\", \"b\", \"b\", \"d\"]\n4-element Array{String,1}:\n \"b\"\n \"b\"\n \"b\"\n \"d\"\n\njulia> c₂ = [\"a\", \"a\", \"c\", \"c\"]\n4-element Array{String,1}:\n \"a\"\n \"a\"\n \"c\"\n \"c\"\n\njulia> #\nx_test_costume = [OrderedConstruct([Mod(m) for m in cᵢ]) for cᵢ in [c₁,c₂]]\n2-element Array{BOMoD.OrderedConstruct{BOMoD.Mod{String}},1}:\n {OrderedConstruct}[\"b\", \"b\", \"b\", \"d\"]\n {OrderedConstruct}[\"a\", \"a\", \"c\", \"c\"]\n","category":"page"},{"location":"man/BO_docs/#","page":"Bayesian optimisation","title":"Bayesian optimisation","text":"Then the x_test_custom can be used in the predict_gp function:","category":"page"},{"location":"man/BO_docs/#","page":"Bayesian optimisation","title":"Bayesian optimisation","text":"julia> prediction_costume = predict_gp(x_test_costume,a_gp_model,m);","category":"page"},{"location":"man/BO_docs/#","page":"Bayesian optimisation","title":"Bayesian optimisation","text":"The output of the predict_gp function is a GPpredict object containing two elements:","category":"page"},{"location":"man/BO_docs/#","page":"Bayesian optimisation","title":"Bayesian optimisation","text":"hatf_pred: contains the Stheno object that holds the prediction values.\nx_test: contains the array of all constructs whose prediction values are available.","category":"page"},{"location":"man/BO_docs/#Batch-sampling-1","page":"Bayesian optimisation","title":"Batch sampling`","text":"","category":"section"},{"location":"man/BO_docs/#","page":"Bayesian optimisation","title":"Bayesian optimisation","text":"The final step in the BOMoD process is to select the best batch of data points, which needs to be evaluated in the lab. Five different sampling methods are available in the package. The first three are based on well-known acquisition functions: probability of improvement (PI), expected improvement (EI), GP process upper confidence bound (GP-UCB). The fourth option is Thompson sampling (TS). As a final option, one can use a random sampling algorithm. All sampling approaches are explained in detail below.","category":"page"},{"location":"man/BO_docs/#Probability-of-improvement-(PI)-1","page":"Bayesian optimisation","title":"Probability of improvement (PI)","text":"","category":"section"},{"location":"man/BO_docs/#","page":"Bayesian optimisation","title":"Bayesian optimisation","text":"The PI of a construct mathbfx with hatmu_r(mathbfx) the mean prediction value and hatsigma_r(mathbfx) the predicted standard deviation of construct mathbfx at iteration r is given by:","category":"page"},{"location":"man/BO_docs/#","page":"Bayesian optimisation","title":"Bayesian optimisation","text":"Phi left(dfrachatmu_r(mathbfx) - f(mathbfx^+) - epsilonhatsigma_r(mathbfx)right) ","category":"page"},{"location":"man/BO_docs/#","page":"Bayesian optimisation","title":"Bayesian optimisation","text":"were Phi indicates the CDF of the standard normal distribution, and f(mathbfx^+) is the current highest observed value. epsilon is a hyperparameter to balance the exploration and exploitation properties of the sampling algorithm.","category":"page"},{"location":"man/BO_docs/#","page":"Bayesian optimisation","title":"Bayesian optimisation","text":"The sampler can be used with the pi_sampler function, which takes four arguments:","category":"page"},{"location":"man/BO_docs/#","page":"Bayesian optimisation","title":"Bayesian optimisation","text":"arg:","category":"page"},{"location":"man/BO_docs/#","page":"Bayesian optimisation","title":"Bayesian optimisation","text":"f_pre: GPpredict object from the predict_gp function\nb: number of newly sampled data points\nfmax: current highest observed activity value.","category":"page"},{"location":"man/BO_docs/#","page":"Bayesian optimisation","title":"Bayesian optimisation","text":"kwarg:","category":"page"},{"location":"man/BO_docs/#","page":"Bayesian optimisation","title":"Bayesian optimisation","text":"epsilon: hyperparameter to balance the exploration and exploitation properties of the sampling algorithm. A higher epsilon value results in a more exploratory sampling algorithm. The default value is zero.","category":"page"},{"location":"man/BO_docs/#","page":"Bayesian optimisation","title":"Bayesian optimisation","text":"The batch of b samples is obtained, after sorting the constructs from high to low given their PI value. The first b data points are returned as a batch.","category":"page"},{"location":"man/BO_docs/#","page":"Bayesian optimisation","title":"Bayesian optimisation","text":"julia> b = 3 ;\n3\n\njulia> fmax = maximum(y_train);\n1.7723410453635258\n\njulia> batch_pi = pi_sampler(prediction,b,fmax)\n3-element Array{BOMoD.OrderedConstruct{BOMoD.Mod{String}},1}:\n {OrderedConstruct}[\"a\", \"b\", \"d\"]\n {OrderedConstruct}[\"a\", \"d\", \"a\"]\n {OrderedConstruct}[\"b\", \"b\", \"b\"]\n","category":"page"},{"location":"man/BO_docs/#Expected-improvement-(EI)-1","page":"Bayesian optimisation","title":"Expected improvement (EI)","text":"","category":"section"},{"location":"man/BO_docs/#","page":"Bayesian optimisation","title":"Bayesian optimisation","text":"The EI of a construct mathbfx with hatmu_r(mathbfx) the mean prediction value  and hatsigma_r(mathbfx) the predicted standard deviation of construct mathbfx at iteration r is given by:","category":"page"},{"location":"man/BO_docs/#","page":"Bayesian optimisation","title":"Bayesian optimisation","text":"    EI(mathbfx) = begincases(hatmu_r(mathbfx)- f(mathbfx^+) - epsilon)Phi(z(mathbfx)) +hatsigma_r(mathbfx)phi(z(mathbfx)) text  if  hatsigma_r(mathbfx)  0 \n\t\t0  text if  hatsigma_r(mathbfx) = 0\n\t\tendcases","category":"page"},{"location":"man/BO_docs/#","page":"Bayesian optimisation","title":"Bayesian optimisation","text":"\n    z(mathbfx) = dfrachatmu_r(mathbfx)- f(mathbfx^+) - epsilonhatsigma_r(mathbfx) ","category":"page"},{"location":"man/BO_docs/#","page":"Bayesian optimisation","title":"Bayesian optimisation","text":"where Phi indicates the CDF of the standard normal distribution, phi indicates the PDF of the standard normal distribution and f(mathbfx^+) is the current highest observed value. epsilon is a hyperparameter to balance the exploration and exploitation properties of the sampling algorithm. hatsigma_r  0 is always true because the GP models from Stheno package  require a minimal noise parameter sigma^2_n.","category":"page"},{"location":"man/BO_docs/#","page":"Bayesian optimisation","title":"Bayesian optimisation","text":"The sampler can be used with the ei_sampler function, which takes four arguments:","category":"page"},{"location":"man/BO_docs/#","page":"Bayesian optimisation","title":"Bayesian optimisation","text":"arg","category":"page"},{"location":"man/BO_docs/#","page":"Bayesian optimisation","title":"Bayesian optimisation","text":"f_pre: GPpredict object from the predict_gp function\nb: number of newly sampled data points\nfmax: current highest observed activity value.","category":"page"},{"location":"man/BO_docs/#","page":"Bayesian optimisation","title":"Bayesian optimisation","text":"kwarg","category":"page"},{"location":"man/BO_docs/#","page":"Bayesian optimisation","title":"Bayesian optimisation","text":"epsilon: hyperparameter to balance the exploration and exploitation properties of the sampling algorithm. A higher epsilon value results in a more exploratory sampling algorithm. The default value is zero.","category":"page"},{"location":"man/BO_docs/#","page":"Bayesian optimisation","title":"Bayesian optimisation","text":"The batch of b samples is obtained, after sorting the constructs from high to low based on their EI values. The first b data points are returned as a batch.","category":"page"},{"location":"man/BO_docs/#","page":"Bayesian optimisation","title":"Bayesian optimisation","text":"julia> b = 3\n3\n\njulia> fmax = maximum(y_train)\n1.7723410453635258\n\njulia> batch_pi = ei_sampler(prediction,b,fmax)\n3-element Array{BOMoD.OrderedConstruct{BOMoD.Mod{String}},1}:\n {OrderedConstruct}[\"a\", \"b\", \"d\"]\n {OrderedConstruct}[\"a\", \"d\", \"a\"]\n {OrderedConstruct}[\"b\", \"b\", \"b\"]\n","category":"page"},{"location":"man/BO_docs/#Gaussian-process-upper-confidence-bound-(GP-UCB)-1","page":"Bayesian optimisation","title":"Gaussian process upper confidence bound (GP-UCB)","text":"","category":"section"},{"location":"man/BO_docs/#","page":"Bayesian optimisation","title":"Bayesian optimisation","text":"The GP-UCB of a construct mathbfx with hatmu_r(mathbfx) the mean prediction value and hatsigma_r(mathbfx) the predicted standard deviation of construct mathbfx at iteration r is given by:","category":"page"},{"location":"man/BO_docs/#","page":"Bayesian optimisation","title":"Bayesian optimisation","text":"textGP-UBC =  hatmu_r(mathbfx) - sqrtbeta hatsigma_r(mathbfx) ","category":"page"},{"location":"man/BO_docs/#","page":"Bayesian optimisation","title":"Bayesian optimisation","text":"where beta is the hyperparameter to balance the exploration and exploitation properties of the algorithm.","category":"page"},{"location":"man/BO_docs/#","page":"Bayesian optimisation","title":"Bayesian optimisation","text":"The algorithm can be used with gpubc_sampler function, which takes three arguments:","category":"page"},{"location":"man/BO_docs/#","page":"Bayesian optimisation","title":"Bayesian optimisation","text":"arg","category":"page"},{"location":"man/BO_docs/#","page":"Bayesian optimisation","title":"Bayesian optimisation","text":"f_pre: GPpredict object from the predict_gp function\nb: number of newly sampled data points.","category":"page"},{"location":"man/BO_docs/#","page":"Bayesian optimisation","title":"Bayesian optimisation","text":"kwarg","category":"page"},{"location":"man/BO_docs/#","page":"Bayesian optimisation","title":"Bayesian optimisation","text":"beta: hyperparameter to balance the exploration and exploitation properties of the sampler, the default value is 1.","category":"page"},{"location":"man/BO_docs/#","page":"Bayesian optimisation","title":"Bayesian optimisation","text":"The batch of b samples is obtained, after sorting the constructs from high to low given their GP-UCB values. The first b data points are returned as a batch.","category":"page"},{"location":"man/BO_docs/#","page":"Bayesian optimisation","title":"Bayesian optimisation","text":"julia> batch_pi = gpucb_sampler(prediction,3)\n3-element Array{BOMoD.OrderedConstruct{BOMoD.Mod{String}},1}:\n {OrderedConstruct}[\"a\", \"a\", \"d\"]\n {OrderedConstruct}[\"b\", \"a\", \"b\"]\n {OrderedConstruct}[\"a\", \"d\", \"b\"]\n","category":"page"},{"location":"man/BO_docs/#","page":"Bayesian optimisation","title":"Bayesian optimisation","text":"An extra feature is introduced in BOMoD. For a sequential GP-UBC, a value of beta can be obtained that bounds the cumulative regret with high probability:","category":"page"},{"location":"man/BO_docs/#","page":"Bayesian optimisation","title":"Bayesian optimisation","text":" beta =  2 ln(dfracx_traint^2π^26delta)","category":"page"},{"location":"man/BO_docs/#","page":"Bayesian optimisation","title":"Bayesian optimisation","text":"with textx_train the number of used training data points, r the current iteration and $ \\delta$ a parameter between zero and one. For more information, see the theoretical derivation described by: Srinivas, Niranjan et al. “Information-Theoretic Regret Bounds for Gaussian Process Optimization in the Bandit Setting.” IEEE Transactions on Information Theory 58.5 (2012): 3250–3265.","category":"page"},{"location":"man/BO_docs/#","page":"Bayesian optimisation","title":"Bayesian optimisation","text":"The above mentioned formula is implemented in the optimal_β$ function that takes three input arguments:","category":"page"},{"location":"man/BO_docs/#","page":"Bayesian optimisation","title":"Bayesian optimisation","text":"arg","category":"page"},{"location":"man/BO_docs/#","page":"Bayesian optimisation","title":"Bayesian optimisation","text":"n: number of training data points\nr: current iteration number","category":"page"},{"location":"man/BO_docs/#","page":"Bayesian optimisation","title":"Bayesian optimisation","text":"kwarg","category":"page"},{"location":"man/BO_docs/#","page":"Bayesian optimisation","title":"Bayesian optimisation","text":"delta: parameter of the function between zero and one. The default value is 0.2.","category":"page"},{"location":"man/BO_docs/#","page":"Bayesian optimisation","title":"Bayesian optimisation","text":"There is less theoretical support that the given beta is also useful for batch sampling, but the option to use this value is made available and was used before in a batch sampling setting","category":"page"},{"location":"man/BO_docs/#Thompson-sampling-(TS)-1","page":"Bayesian optimisation","title":"Thompson sampling (TS)","text":"","category":"section"},{"location":"man/BO_docs/#","page":"Bayesian optimisation","title":"Bayesian optimisation","text":"The TS algorithm works differently compared to the above acquisition functions. It is based on a stochastic sampling procedure that is repeated b times:","category":"page"},{"location":"man/BO_docs/#","page":"Bayesian optimisation","title":"Bayesian optimisation","text":"textsample y_i sim mathcalN(hatmu_r(mathbfx)hatsigma_r(mathbfx))","category":"page"},{"location":"man/BO_docs/#","page":"Bayesian optimisation","title":"Bayesian optimisation","text":"\tmathbfx_n+1 = undersetmathbfx in S setminus mathbfXtextargmax(y_i)","category":"page"},{"location":"man/BO_docs/#","page":"Bayesian optimisation","title":"Bayesian optimisation","text":"with hatmu_r(mathbfx) the mean prediction value and hatsigma_r(mathbfx) the predicted standard deviation of construct mathbfx at iteration r of the BOMoD algorithm.","category":"page"},{"location":"man/BO_docs/#","page":"Bayesian optimisation","title":"Bayesian optimisation","text":"arg","category":"page"},{"location":"man/BO_docs/#","page":"Bayesian optimisation","title":"Bayesian optimisation","text":"f_pre: GPpredict object from the predict_gp function\nb: number of data points in a batch","category":"page"},{"location":"man/BO_docs/#","page":"Bayesian optimisation","title":"Bayesian optimisation","text":"julia> b = 3\n3\n\njulia> batch_pi = ts_sampler(prediction,b)\n3-element Array{BOMoD.OrderedConstruct{BOMoD.Mod{String}},1}:\n {OrderedConstruct}[\"b\", \"a\", \"d\"]\n {OrderedConstruct}[\"d\", \"a\", \"d\"]\n {OrderedConstruct}[\"a\", \"b\", \"d\"]\n","category":"page"},{"location":"man/BO_docs/#Random-sampling-1","page":"Bayesian optimisation","title":"Random sampling","text":"","category":"section"},{"location":"man/BO_docs/#","page":"Bayesian optimisation","title":"Bayesian optimisation","text":"The final sampling algorithm is a simple random sampling algorithm. In this case, the construction of a model is, of course not needed.","category":"page"},{"location":"man/BO_docs/#Combination-of-samplers-1","page":"Bayesian optimisation","title":"Combination of samplers","text":"","category":"section"},{"location":"man/BO_docs/#","page":"Bayesian optimisation","title":"Bayesian optimisation","text":"The use of the random sampling algorithm as single sampler should be avoided, but it can be used in combination with one of the other samplers. This depends on the desired properties of the obtained batch because the new data points have two different functions:","category":"page"},{"location":"man/BO_docs/#","page":"Bayesian optimisation","title":"Bayesian optimisation","text":"obtain highly active constructs\nimprove the prediction capacities of the GP model to sample better constructs in the next iteration cycle","category":"page"},{"location":"man/BO_docs/#","page":"Bayesian optimisation","title":"Bayesian optimisation","text":"Using different samplers with different properties can result in a batch that contributes to these two functionalities.","category":"page"},{"location":"man/BO_docs/#","page":"Bayesian optimisation","title":"Bayesian optimisation","text":"The current version of BOMoD does not directly combine different samplers. Still, with a small addition of code, combinations can be made. A small example is given: Let b be the size of the batch, then one can use the EI algorithm to fill the first half of the batch. Afterwards, one can continue with random sampling to explore the design space.","category":"page"},{"location":"man/BO_docs/#","page":"Bayesian optimisation","title":"Bayesian optimisation","text":"julia> # inputs\nb = 4\n4\n\njulia> fmax = maximum(y_train)\n1.7723410453635258\n\njulia> # split the batch\nb_ei = round(b/2) |> Int\n2\n\njulia> b_random = b - b_ei |> Int\n2\n\njulia> #  sample EI\nnew_construct_ei = ei_sampler(prediction,b_ei,fmax)\n2-element Array{BOMoD.OrderedConstruct{BOMoD.Mod{String}},1}:\n {OrderedConstruct}[\"a\", \"b\", \"d\"]\n {OrderedConstruct}[\"a\", \"d\", \"a\"]\n\njulia> #  filter, avoid resampling\nx_test = filter(x-> !(x in new_construct_ei) ,prediction.x_test)\n59-element Array{BOMoD.OrderedConstruct{BOMoD.Mod{String}},1}:\n {OrderedConstruct}[\"a\", \"a\", \"a\"]\n {OrderedConstruct}[\"a\", \"a\", \"c\"]\n {OrderedConstruct}[\"a\", \"a\", \"d\"]\n {OrderedConstruct}[\"a\", \"b\", \"a\"]\n {OrderedConstruct}[\"a\", \"b\", \"b\"]\n {OrderedConstruct}[\"a\", \"b\", \"c\"]\n {OrderedConstruct}[\"a\", \"c\", \"a\"]\n {OrderedConstruct}[\"a\", \"c\", \"b\"]\n {OrderedConstruct}[\"a\", \"c\", \"c\"]\n {OrderedConstruct}[\"a\", \"c\", \"d\"]\n ⋮\n {OrderedConstruct}[\"d\", \"b\", \"d\"]\n {OrderedConstruct}[\"d\", \"c\", \"a\"]\n {OrderedConstruct}[\"d\", \"c\", \"b\"]\n {OrderedConstruct}[\"d\", \"c\", \"c\"]\n {OrderedConstruct}[\"d\", \"c\", \"d\"]\n {OrderedConstruct}[\"d\", \"d\", \"a\"]\n {OrderedConstruct}[\"d\", \"d\", \"b\"]\n {OrderedConstruct}[\"d\", \"d\", \"c\"]\n {OrderedConstruct}[\"d\", \"d\", \"d\"]\n\njulia> # sampler random\nnew_random = sample(x_test,b_random)\n2-element Array{BOMoD.OrderedConstruct{BOMoD.Mod{String}},1}:\n {OrderedConstruct}[\"c\", \"b\", \"a\"]\n {OrderedConstruct}[\"a\", \"a\", \"d\"]\n\njulia> # Concatend both batches\n[new_construct_ei;new_random]\n4-element Array{BOMoD.OrderedConstruct{BOMoD.Mod{String}},1}:\n {OrderedConstruct}[\"a\", \"b\", \"d\"]\n {OrderedConstruct}[\"a\", \"d\", \"a\"]\n {OrderedConstruct}[\"c\", \"b\", \"a\"]\n {OrderedConstruct}[\"a\", \"a\", \"d\"]\n","category":"page"},{"location":"man/BO_docs/#Iteration-1","page":"Bayesian optimisation","title":"Iteration","text":"","category":"section"},{"location":"man/BO_docs/#","page":"Bayesian optimisation","title":"Bayesian optimisation","text":"The BOMoD algorithm is an iterative procedure. The final two steps should be repeated after evaluating the newly proposed data points. The GP model is then fitted on a more extensive training set, which improves the prediction capacity of the model. Afterwards, the updated model is used in a batch sampling algorithm to propose a new batch of data points. The number of iterations depends on the goal of the research and on the available budget.","category":"page"},{"location":"man/design/#Constructing-design-space-1","page":"Constructing design space","title":"Constructing design space","text":"","category":"section"},{"location":"man/design/#","page":"Constructing design space","title":"Constructing design space","text":"The setup of a modular design problem requires the construction of the design space containing all different combinations. Using the BOMoD package, this can be done in a few easy steps.","category":"page"},{"location":"man/design/#Set-design-inputs-1","page":"Constructing design space","title":"Set design inputs","text":"","category":"section"},{"location":"man/design/#","page":"Constructing design space","title":"Constructing design space","text":"To start a BOMoD project the package has to be loaded:","category":"page"},{"location":"man/design/#","page":"Constructing design space","title":"Constructing design space","text":"julia> using BOMoD;\n","category":"page"},{"location":"man/design/#","page":"Constructing design space","title":"Constructing design space","text":"Afterwards three mandatory arguments need to be defined:","category":"page"},{"location":"man/design/#","page":"Constructing design space","title":"Constructing design space","text":"Input modules\nLength of the construct\nDesired construct type","category":"page"},{"location":"man/design/#Input-modules-1","page":"Constructing design space","title":"Input modules","text":"","category":"section"},{"location":"man/design/#","page":"Constructing design space","title":"Constructing design space","text":"Every combinatorial design problem starts with the given input modules. These are the individual building blocks that are used to make all different combinations. First, a custom type Mod{T} where T <: Any is implemented to store a single module element. For example, a single module :sym4 can be introduced as:","category":"page"},{"location":"man/design/#","page":"Constructing design space","title":"Constructing design space","text":"julia> using BOMoD: Mod\n\njulia>     md_symbol = Mod(:sym4)\nBOMoD.Mod{Symbol}(:sym4)\n\njulia>     md_string = Mod(\"a\")\nBOMoD.Mod{String}(\"a\")\n","category":"page"},{"location":"man/design/#","page":"Constructing design space","title":"Constructing design space","text":"Of course, multiple modules are needed to obtain different combinations and a new type Groupmod is introduced to group different modules.","category":"page"},{"location":"man/design/#","page":"Constructing design space","title":"Constructing design space","text":"julia> using BOMoD: GroupMod\n\njulia> md_group = GroupMod([Mod(\"a\"), Mod(\"b\"), Mod(\"c\"), Mod(\"d\"), Mod(\"e\")]);\n{GroupMod}{\"a\", \"b\", \"c\", \"d\", \"e\"}\n","category":"page"},{"location":"man/design/#","page":"Constructing design space","title":"Constructing design space","text":"As indicated, GroupMod and Mod types are not directly exported from the BOMoD module. This is because a function groupmod is available to facilitate the input of the different modules. This function takes as argument a Vector{T} with all elements that should be transformed into the module type. Additionally, the function avoids the duplication of the same modules and sorts out the inputs alphabetically to get reproducible results.","category":"page"},{"location":"man/design/#","page":"Constructing design space","title":"Constructing design space","text":"julia> md_group3 = groupmod([\"a\", \"b\", \"c\", \"d\", \"e\"])\n{GroupMod}{\"a\", \"b\", \"c\", \"d\", \"e\"}\n\njulia> md_group4 = groupmod([\"b\", \"c\", \"a\", \"d\", \"e\", \"e\"])\n{GroupMod}{\"a\", \"b\", \"c\", \"d\", \"e\"}\n","category":"page"},{"location":"man/design/#","page":"Constructing design space","title":"Constructing design space","text":"The user of the package is advised to use the groupmod function.","category":"page"},{"location":"man/design/#Length-of-the-construct-1","page":"Constructing design space","title":"Length of the construct","text":"","category":"section"},{"location":"man/design/#","page":"Constructing design space","title":"Constructing design space","text":"The length is an integer value representing the number of modules that are allowed to make a single construct. Multiple lengths are possible by combining different design setups. See the design   below for more information. The running example will contain three modules.","category":"page"},{"location":"man/design/#","page":"Constructing design space","title":"Constructing design space","text":"julia> l = 3;\n3\n","category":"page"},{"location":"man/design/#Desired-construct-type-1","page":"Constructing design space","title":"Desired construct type","text":"","category":"section"},{"location":"man/design/#","page":"Constructing design space","title":"Constructing design space","text":"Every construct type has its own specific combinatorial properties which are defined by using the order keyword argument. Currently, the package supports two different construct types:","category":"page"},{"location":"man/design/#","page":"Constructing design space","title":"Constructing design space","text":"OrderedConstruct: order=true\nUnorderedConstruct : order=false","category":"page"},{"location":"man/design/#","page":"Constructing design space","title":"Constructing design space","text":"OrderedConstruct is a construct where the relative position of different modules influences the performance of the product. This has two consequences: first, the combinations with the same modules but in a different order have a different activity and are seen as two different configurations. e.g. [\"a\", \"b\", \"c\"], [\"c\", \"b\", \"a\"] are seen as to different combinations. Secondly, the construct is allowed to have the same module multiple times in one variant e.g. [\"a\", \"a\", \"c\"]. This setting is mathematically equivalent to permutations with replacements as seen in .","category":"page"},{"location":"man/design/#","page":"Constructing design space","title":"Constructing design space","text":"UnorderedConstruct is a construct type where the interaction between modules is independent from their order. This indicates that the order of the different modules has no physical meaning. As a result, every combination containing the same modules is seen equal, and only a single combination is generated, e.g. [\"a\", \"b\", \"c\"], [\"c\", \"b\", \"a\"] are seen as the same combinations and only a single variant is generated. In BOMoD, the later is made because all combinations are constructed in decreasing lexicographical order, which facilitates their construction internally. Because there is no direct order among the modules, it is not useful to evaluate constructs containing the same module multiple times. This setting is mathematically equivalent to combinations without replacements as seen in.","category":"page"},{"location":"man/design/#","page":"Constructing design space","title":"Constructing design space","text":"To continue the example, the order is set to true","category":"page"},{"location":"man/design/#","page":"Constructing design space","title":"Constructing design space","text":"julia> order = true;\ntrue\n","category":"page"},{"location":"man/design/#Constraints-1","page":"Constructing design space","title":"Constraints","text":"","category":"section"},{"location":"man/design/#","page":"Constructing design space","title":"Constructing design space","text":"Constraints are used to remove specific combinations that are forbidden in the design space, the input of constraints is optional.\\\nMany constraints are possible. Currently, two types are implemented: UnOrderedConstraint and OrderedConstraint. The UnOrderedConstraint has only an array of modules as input and the occurrence of all these modules in one construct is forbidden. The OrderedConstraint has two inputs, one are the position indices, and the second one represents the corresponding module that is forbidden on the given position. Both constraint types are grouped under the SingleConstructConstraints abstract type.","category":"page"},{"location":"man/design/#","page":"Constructing design space","title":"Constructing design space","text":"To illustrate the different constraints, different examples are given. A construct can be evaluated with the internal filterconstraint(construct, constraint) function. The function returns true if the construct is forbidden and false when allowed.","category":"page"},{"location":"man/design/#","page":"Constructing design space","title":"Constructing design space","text":"To illustrate the various constraint types, some example constructs are made:","category":"page"},{"location":"man/design/#","page":"Constructing design space","title":"Constructing design space","text":"julia> using BOMoD: filterconstraint\n\njulia> c1 = OrderedConstruct([Mod(\"a\"), Mod(\"b\"), Mod(\"c\")]);\n{OrderedConstruct}[\"a\", \"b\", \"c\"]\n\njulia> c2 = OrderedConstruct([Mod(\"a\"), Mod(\"c\"), Mod(\"b\")]);\n{OrderedConstruct}[\"a\", \"c\", \"b\"]\n\njulia> c3 = OrderedConstruct([Mod(\"a\"), Mod(\"c\"), Mod(\"a\")]);\n{OrderedConstruct}[\"a\", \"c\", \"a\"]\n","category":"page"},{"location":"man/design/#illustration-of-UnOrderedConstraint-1","page":"Constructing design space","title":"illustration of UnOrderedConstraint","text":"","category":"section"},{"location":"man/design/#","page":"Constructing design space","title":"Constructing design space","text":"julia> # removes the construct containing Mod(\"a\") and Mod(\"b\");\ncon_unorder = UnOrderedConstraint([Mod(\"a\"), Mod(\"b\")]);\nBOMoD.UnOrderedConstraint{BOMoD.Mod{String}}(BOMoD.Mod{String}[BOMoD.Mod{String}(\"a\"), BOMoD.Mod{String}(\"b\")])\n\njulia>\n# evaluate true, contains Mod(\"a\") and Mod(\"b\"), will be removed\nfilterconstraint(c1,con_unorder)\ntrue\n\njulia>\n# evaluate true, contains Mod(\"a\") and Mod(\"b\"), will be removed\nfilterconstraint(c2,con_unorder)\ntrue\n\njulia>\n# evaluate false, only contains Mod(\"a\"), will be keptfilterconstraint(c3,con_unorder)\n","category":"page"},{"location":"man/design/#illustration-of-OrderedConstraint-1","page":"Constructing design space","title":"illustration of OrderedConstraint","text":"","category":"section"},{"location":"man/design/#","page":"Constructing design space","title":"Constructing design space","text":"julia> #  Mod(\"a\") cannot be on position 1 and Mod(\"b\") cannot be on position 2\ncon_order = OrderedConstraint([1, 2],[Mod(\"a\"), Mod(\"b\")]);\nBOMoD.OrderedConstraint{BOMoD.Mod{String}}([1, 2], BOMoD.Mod{String}[BOMoD.Mod{String}(\"a\"), BOMoD.Mod{String}(\"b\")])\n\njulia>\n# evaluates to true, contains Mod(\"a\") at index 1 and Mod(\"b\") ad index 2\n# the construct  will be removed\nfilterconstraint(c1,con_order)\ntrue\n\njulia>\n\n# evaluates to  false, contains Mod(\"a\") and (\"b\") but not at the forbidden index\n# the construct  will be kept\nfilterconstraint(c2,con_order)\nfalse\n\njulia>\n# evaluates to  false, contains only Mod(\"a\"), will be kept\nfilterconstraint(c3,con_order)\nfalse\n","category":"page"},{"location":"man/design/#","page":"Constructing design space","title":"Constructing design space","text":"Multiple constraints can be combined in a single design setup after concatenation. This results in a ComposedConstructConstraints. If the given construct is forbidden based on one of the concatenated constraints, the construct is removed.","category":"page"},{"location":"man/design/#illustration-of-ComposedConstructConstraints-1","page":"Constructing design space","title":"illustration of ComposedConstructConstraints","text":"","category":"section"},{"location":"man/design/#","page":"Constructing design space","title":"Constructing design space","text":"julia> using BOMoD: ComposedConstructConstraints;\n\njulia> con_unorder = UnOrderedConstraint([Mod(\"a\") ,Mod(\"b\")]);\nBOMoD.UnOrderedConstraint{BOMoD.Mod{String}}(BOMoD.Mod{String}[BOMoD.Mod{String}(\"a\"), BOMoD.Mod{String}(\"b\")])\n\njulia> con_under2 = UnOrderedConstraint([Mod(\"a\"), Mod(\"c\")]);\nBOMoD.UnOrderedConstraint{BOMoD.Mod{String}}(BOMoD.Mod{String}[BOMoD.Mod{String}(\"a\"), BOMoD.Mod{String}(\"c\")])\n\njulia> # combine constrains\ncompose = con_under2 + con_unorder;\nBOMoD.ComposedConstructConstraints{BOMoD.UnOrderedConstraint{BOMoD.Mod{String}}}(BOMoD.UnOrderedConstraint{BOMoD.Mod{String}}[BOMoD.UnOrderedConstraint{BOMoD.Mod{String}}(BOMoD.Mod{String}[BOMoD.Mod{String}(\"a\"), BOMoD.Mod{String}(\"c\")]), BOMoD.UnOrderedConstraint{BOMoD.Mod{String}}(BOMoD.Mod{String}[BOMoD.Mod{String}(\"a\"), BOMoD.Mod{String}(\"b\")])])\n\njulia>\n#  true, rejected by the first constraint\nfilterconstraint(c1,compose)\ntrue\n\njulia>\n# true, rejected by the second constraint\nfilterconstraint(c3,compose)\ntrue\n","category":"page"},{"location":"man/design/#Construct-design-1","page":"Constructing design space","title":"Construct design","text":"","category":"section"},{"location":"man/design/#Type-hierarchy:-design-1","page":"Constructing design space","title":"Type hierarchy: design","text":"","category":"section"},{"location":"man/design/#","page":"Constructing design space","title":"Constructing design space","text":"Different designs are possible in the package. For careful integration of all the different options, various Julia types were created. As a result, the following hierarchy was obtained:","category":"page"},{"location":"man/design/#","page":"Constructing design space","title":"Constructing design space","text":"AbstractDesign\nSingleDesign\nOrderedDesign\nUnorderedDesign\n2)MultiDesign","category":"page"},{"location":"man/design/#","page":"Constructing design space","title":"Constructing design space","text":"At the top, there is the AbstractDesign type which is used for all designs. Then, two new types are defined: SingleDesign and MultiDesign which requires some additional explanation. First, the SingleDesign type is explained, afterwards the MultiDesign type.","category":"page"},{"location":"man/design/#Make-SingleDesign-1","page":"Constructing design space","title":"Make SingleDesign","text":"","category":"section"},{"location":"man/design/#","page":"Constructing design space","title":"Constructing design space","text":"All different SingleDesign types can be obtained with a single function: constructdesign. This function requires three input arguments, as discussed in  : the input modules m, the length l and the design type order.","category":"page"},{"location":"man/design/#","page":"Constructing design space","title":"Constructing design space","text":"julia> m = groupmod([\"a\", \"b\", \"c\", \"d\", \"e\"]);\n{GroupMod}{\"a\", \"b\", \"c\", \"d\", \"e\"}\n\njulia> design = constructdesign(m, l, order=order);\nUsed modules : {GroupMod}{\"a\", \"b\", \"c\", \"d\", \"e\"}\nallowed length : 3\nconstraints : BOMoD.NoConstraint{Nothing}(nothing)\n\t \t designspace\n spacetype | BOMoD.FullOrderedSpace{BOMoD.Mod{String}}\n generated constructs | BOMoD.OrderedConstruct{BOMoD.Mod{String}}\n n_consturcts | 125\n","category":"page"},{"location":"man/design/#","page":"Constructing design space","title":"Constructing design space","text":"If needed, constraints can be integrated in the function easily:","category":"page"},{"location":"man/design/#","page":"Constructing design space","title":"Constructing design space","text":"julia> con_unorder = UnOrderedConstraint([ Mod(\"a\"), Mod(\"b\")]);\nBOMoD.UnOrderedConstraint{BOMoD.Mod{String}}(BOMoD.Mod{String}[BOMoD.Mod{String}(\"a\"), BOMoD.Mod{String}(\"b\")])\n\njulia> design = constructdesign(m, l, con_unorder, order=order);\nUsed modules : {GroupMod}{\"a\", \"b\", \"c\", \"d\", \"e\"}\nallowed length : 3\nconstraints : BOMoD.UnOrderedConstraint{BOMoD.Mod{String}}(BOMoD.Mod{String}[BOMoD.Mod{String}(\"a\"), BOMoD.Mod{String}(\"b\")])\n\t \t designspace\nEffspace: spacetype | BOMoD.FullOrderedSpace{BOMoD.Mod{String}}\n generated constructs | BOMoD.OrderedConstruct{BOMoD.Mod{String}}\n n_consturcts | 125\nconstraint:BOMoD.UnOrderedConstraint{BOMoD.Mod{String}}(BOMoD.Mod{String}[BOMoD.Mod{String}(\"a\"), BOMoD.Mod{String}(\"b\")])\n","category":"page"},{"location":"man/design/#","page":"Constructing design space","title":"Constructing design space","text":"The output of this function results in an OrderedDesign or UnorderedDesign. The function generates an OrderedDesign when the order argument is true. The design will then produce OrderedConstruct. The opposite holds for an UnorderedDesign, which creates an UnorderedConstruct and is enabled when the order argument is false. Still, the underlying structure of both types is similar. Both contain four different fields, the output is complex and the different fields are summarised in Table .","category":"page"},{"location":"man/design/#","page":"Constructing design space","title":"Constructing design space","text":"name type explanation\nmod AbstractMod The used modules in the design\nlen Int The allowed length of the constructs\ncon AbstractConstraints The constraints of the design space\nspace AbstractSpace The design space containing all constructs","category":"page"},{"location":"man/design/#","page":"Constructing design space","title":"Constructing design space","text":"The first three fields are the input parameters and they are stored to allow the user to verify which inputs were used. If no constraints were given as input, the con field will be filled with NoConstraint(nothing) by default. All three inputs are used to construct the space object. All two SingleDesign structures can be seen as data containers to allow well-organised data flow in the package. It is the space object that absorbs all given input and stores the desired output. Different space types were implemented. To understand them correctly, some additional explanation is required.","category":"page"},{"location":"man/design/#","page":"Constructing design space","title":"Constructing design space","text":"The space argument of a SingleDesign holds all different combinations, without the explicit creation of all of them. This is an elaborate concept in the philosophy of the BOMoD package. The construction and storage of all combinations would not be trivial in many cases, due to the large number of possibilities. To make this possible, the package uses some custom implemented mathematical operations between modules to generate constructs efficiently on the fly.","category":"page"},{"location":"man/design/#","page":"Constructing design space","title":"Constructing design space","text":"The multiplication of different modules results in an OrderedConstruct of the given modules. The squared brackets \"[]\" indicate that the obtained construct is an array. The positions of the modules are important, a characteristic of an OrderedConstruct.","category":"page"},{"location":"man/design/#","page":"Constructing design space","title":"Constructing design space","text":"julia> Mod(\"a\") * Mod(\"b\") *  Mod(\"c\")\n{OrderedConstruct}[\"a\", \"b\", \"c\"]\n","category":"page"},{"location":"man/design/#","page":"Constructing design space","title":"Constructing design space","text":"The concatenation of different constructs results in an UnorderedConstruct. The curly brackets \"{\" indicates that the output construct is a set. The position of individual modules is not important, a characteristic of an UnorderedConstruct.","category":"page"},{"location":"man/design/#","page":"Constructing design space","title":"Constructing design space","text":"julia> Mod(\"a\") +  Mod(\"b\") +  Mod(\"c\")\n{UnorderedConstruct}{\"a\", \"b\", \"c\"}\n","category":"page"},{"location":"man/design/#","page":"Constructing design space","title":"Constructing design space","text":"More information regarding the different space types is given in the  .","category":"page"},{"location":"man/design/#Make-MultiDesign-1","page":"Constructing design space","title":"Make MultiDesign","text":"","category":"section"},{"location":"man/design/#","page":"Constructing design space","title":"Constructing design space","text":"The MultiDesign type allows the combination of different SingleDesign objects, which is mainly useful to obtain design spaces with variants of different lengths. The structure stores different individual designs and treats them as if they were one. MultiDesign type can be obtained with the concatenation of different SingleDesign. For example, to generate all combinations of length 2, 3 and 4:","category":"page"},{"location":"man/design/#","page":"Constructing design space","title":"Constructing design space","text":"julia> design_len2 = constructdesign(m, 2, order=order);\nUsed modules : {GroupMod}{\"a\", \"b\", \"c\", \"d\", \"e\"}\nallowed length : 2\nconstraints : BOMoD.NoConstraint{Nothing}(nothing)\n\t \t designspace\n spacetype | BOMoD.FullOrderedSpace{BOMoD.Mod{String}}\n generated constructs | BOMoD.OrderedConstruct{BOMoD.Mod{String}}\n n_consturcts | 25\n\njulia> design_len3 = constructdesign(m, 3, order=order);\nUsed modules : {GroupMod}{\"a\", \"b\", \"c\", \"d\", \"e\"}\nallowed length : 3\nconstraints : BOMoD.NoConstraint{Nothing}(nothing)\n\t \t designspace\n spacetype | BOMoD.FullOrderedSpace{BOMoD.Mod{String}}\n generated constructs | BOMoD.OrderedConstruct{BOMoD.Mod{String}}\n n_consturcts | 125\n\njulia> design_len4 = constructdesign(m, 4, order=order);\nUsed modules : {GroupMod}{\"a\", \"b\", \"c\", \"d\", \"e\"}\nallowed length : 4\nconstraints : BOMoD.NoConstraint{Nothing}(nothing)\n\t \t designspace\n spacetype | BOMoD.FullOrderedSpace{BOMoD.Mod{String}}\n generated constructs | BOMoD.OrderedConstruct{BOMoD.Mod{String}}\n n_consturcts | 625\n\njulia> t = design_len2 + design_len3  + design_len4\nNumber of single designs: 3\n\nUsed modules : {GroupMod}{\"a\", \"b\", \"c\", \"d\", \"e\"}\nallowed length : 2\nconstraints : BOMoD.NoConstraint{Nothing}(nothing)\n\t \t designspace\n spacetype | BOMoD.FullOrderedSpace{BOMoD.Mod{String}}\n generated constructs | BOMoD.OrderedConstruct{BOMoD.Mod{String}}\n n_consturcts | 25\n\nUsed modules : {GroupMod}{\"a\", \"b\", \"c\", \"d\", \"e\"}\nallowed length : 3\nconstraints : BOMoD.NoConstraint{Nothing}(nothing)\n\t \t designspace\n spacetype | BOMoD.FullOrderedSpace{BOMoD.Mod{String}}\n generated constructs | BOMoD.OrderedConstruct{BOMoD.Mod{String}}\n n_consturcts | 125\n\nUsed modules : {GroupMod}{\"a\", \"b\", \"c\", \"d\", \"e\"}\nallowed length : 4\nconstraints : BOMoD.NoConstraint{Nothing}(nothing)\n\t \t designspace\n spacetype | BOMoD.FullOrderedSpace{BOMoD.Mod{String}}\n generated constructs | BOMoD.OrderedConstruct{BOMoD.Mod{String}}\n n_consturcts | 625\n\n","category":"page"},{"location":"man/design/#The-space-object-1","page":"Constructing design space","title":"The space object","text":"","category":"section"},{"location":"man/design/#","page":"Constructing design space","title":"Constructing design space","text":"The design structure is mainly a data container that is implemented as a safety step to verify whether all input arguments are correct. A special function: getspace is made to get access to the space object. Additionally, one can choose to obtain all constructs explicitly, which results in a ComputedSpace structure.","category":"page"},{"location":"man/design/#","page":"Constructing design space","title":"Constructing design space","text":"julia> design = constructdesign(m, l, order=order);\nUsed modules : {GroupMod}{\"a\", \"b\", \"c\", \"d\", \"e\"}\nallowed length : 3\nconstraints : BOMoD.NoConstraint{Nothing}(nothing)\n\t \t designspace\n spacetype | BOMoD.FullOrderedSpace{BOMoD.Mod{String}}\n generated constructs | BOMoD.OrderedConstruct{BOMoD.Mod{String}}\n n_consturcts | 125\n\njulia> # get the space object from the design\nspace = getspace(design);\n spacetype | BOMoD.FullOrderedSpace{BOMoD.Mod{String}}\n generated constructs | BOMoD.OrderedConstruct{BOMoD.Mod{String}}\n n_consturcts | 125\n\njulia> # get all different construct explicitly\nspace_full = getspace(design, full = true)\n spacetype | BOMoD.ComputedSpace{Array{BOMoD.OrderedConstruct{BOMoD.Mod{String}},1}}\n generated constructs | BOMoD.OrderedConstruct{BOMoD.Mod{String}}\n n_consturcts | 125\n","category":"page"},{"location":"man/design/#","page":"Constructing design space","title":"Constructing design space","text":"The current implementation has some limitations. Especially when constraints are added, the obtained space is not that efficient as for the non-constrained case. Because constrained and non-constrained spaces have to be treated differently, various space types were made.","category":"page"},{"location":"man/design/#EffSpace-1","page":"Constructing design space","title":"EffSpace","text":"","category":"section"},{"location":"man/design/#","page":"Constructing design space","title":"Constructing design space","text":"All non-constrained spaces have the same abstract type EffSpace. There are two types of EffSpace: FullOrderedSpace, FullUnorderedSpace, respectively referring to the fact that the space object contains constructs of the type OrderedConstruct or UnorderedConstruct.","category":"page"},{"location":"man/design/#","page":"Constructing design space","title":"Constructing design space","text":"A EffSpace object can be handled as if all constructs were stored in a vector. As consequence many desired functions e.g. indexing, random sampling, etc. work without the need of constructing the array containing all combinations. Only the desired constructs are created on the fly, which is an important accomplishment of the BOMoD package. The length of the given space is calculated using well-known formulas from the field of combinatorics which were given in Table , .","category":"page"},{"location":"man/design/#","page":"Constructing design space","title":"Constructing design space","text":"julia> using StatsBase\n\njulia> using Random\n\njulia> # indexing,\nspace[1]\n{OrderedConstruct}[\"a\", \"a\", \"a\"]\n\njulia> # number of constructs\nn_total = length(space)\n125\n\njulia> # iterator over the whole space\nspace_iter = [i for i in space]\n125-element Array{BOMoD.OrderedConstruct{BOMoD.Mod{String}},1}:\n {OrderedConstruct}[\"a\", \"a\", \"a\"]\n {OrderedConstruct}[\"a\", \"a\", \"b\"]\n {OrderedConstruct}[\"a\", \"a\", \"c\"]\n {OrderedConstruct}[\"a\", \"a\", \"d\"]\n {OrderedConstruct}[\"a\", \"a\", \"e\"]\n {OrderedConstruct}[\"a\", \"b\", \"a\"]\n {OrderedConstruct}[\"a\", \"b\", \"b\"]\n {OrderedConstruct}[\"a\", \"b\", \"c\"]\n {OrderedConstruct}[\"a\", \"b\", \"d\"]\n {OrderedConstruct}[\"a\", \"b\", \"e\"]\n ⋮\n {OrderedConstruct}[\"e\", \"d\", \"b\"]\n {OrderedConstruct}[\"e\", \"d\", \"c\"]\n {OrderedConstruct}[\"e\", \"d\", \"d\"]\n {OrderedConstruct}[\"e\", \"d\", \"e\"]\n {OrderedConstruct}[\"e\", \"e\", \"a\"]\n {OrderedConstruct}[\"e\", \"e\", \"b\"]\n {OrderedConstruct}[\"e\", \"e\", \"c\"]\n {OrderedConstruct}[\"e\", \"e\", \"d\"]\n {OrderedConstruct}[\"e\", \"e\", \"e\"]\n\njulia> # collect the space in a vector\nspace_full = collect(space)\n125-element Array{BOMoD.OrderedConstruct{BOMoD.Mod{String}},1}:\n {OrderedConstruct}[\"a\", \"a\", \"a\"]\n {OrderedConstruct}[\"a\", \"a\", \"b\"]\n {OrderedConstruct}[\"a\", \"a\", \"c\"]\n {OrderedConstruct}[\"a\", \"a\", \"d\"]\n {OrderedConstruct}[\"a\", \"a\", \"e\"]\n {OrderedConstruct}[\"a\", \"b\", \"a\"]\n {OrderedConstruct}[\"a\", \"b\", \"b\"]\n {OrderedConstruct}[\"a\", \"b\", \"c\"]\n {OrderedConstruct}[\"a\", \"b\", \"d\"]\n {OrderedConstruct}[\"a\", \"b\", \"e\"]\n ⋮\n {OrderedConstruct}[\"e\", \"d\", \"b\"]\n {OrderedConstruct}[\"e\", \"d\", \"c\"]\n {OrderedConstruct}[\"e\", \"d\", \"d\"]\n {OrderedConstruct}[\"e\", \"d\", \"e\"]\n {OrderedConstruct}[\"e\", \"e\", \"a\"]\n {OrderedConstruct}[\"e\", \"e\", \"b\"]\n {OrderedConstruct}[\"e\", \"e\", \"c\"]\n {OrderedConstruct}[\"e\", \"e\", \"d\"]\n {OrderedConstruct}[\"e\", \"e\", \"e\"]\n\njulia> # sample random 5 constructs\nrng = MersenneTwister();\n\njulia> random_sample = sample(rng,space,5)\n5-element Array{BOMoD.OrderedConstruct{BOMoD.Mod{String}},1}:\n {OrderedConstruct}[\"b\", \"d\", \"a\"]\n {OrderedConstruct}[\"c\", \"d\", \"e\"]\n {OrderedConstruct}[\"c\", \"e\", \"a\"]\n {OrderedConstruct}[\"c\", \"b\", \"d\"]\n {OrderedConstruct}[\"e\", \"e\", \"c\"]\n","category":"page"},{"location":"man/design/#FrameSpace-1","page":"Constructing design space","title":"FrameSpace","text":"","category":"section"},{"location":"man/design/#","page":"Constructing design space","title":"Constructing design space","text":"When constraints are added, an additional space type was introduced: FrameSpace. This FrameSpace type has two arguments. The first argument stores the given constraints, the other one the closest EffSpace which is the space that would be obtained when no constraints were given. The efficiency of this space type drops because the constraints forbid some of the constructs. There is no efficient way to obtain these spaces, and all combinations are evaluated, based on a match towards the given constraints. This matching process iteratively loops over the entire design space. Indexing is no longer possible. The length calculation is done inefficiently. Instead of using a formula, every construct is evaluated for the given constraints to obtain the number of allowed combinations. The uniformly random sampling algorithm of n constructs is based on the rejection of the forbidden constructs. The sampler is hooked on the base sampling function of Julia to assure a correct sampling procedure. As a result, it works well for n ll length of the design space and if the number of constraints is not too high. When using many constraints, it is advised to store the entire design space in an array.","category":"page"},{"location":"man/design/#","page":"Constructing design space","title":"Constructing design space","text":"A particular space type,MultiSpace is introduced for space originating from multiple designs. The space groups multiple SingleSpace and tries to mimic as they originate from one larger design object.","category":"page"},{"location":"man/design/#","page":"Constructing design space","title":"Constructing design space","text":"Note: Most of all types explained above are generated automatically within the BOMoD pipeline. See the quick-start section on github to get a more practical overview of the package.","category":"page"}]
}
